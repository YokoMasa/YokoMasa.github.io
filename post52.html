<!DOCTYPE html>
<html>
 <head>
  <title>
   Ethereum Beige Paperを日本語に訳してみる | 技術記事 | Masa's World
  </title>
  <!--<meta name="description" content="masa&#39;s blog">-->
  <meta content="width=device-width,initial-scale=1" name="viewport"/>
  <link data-turbolinks-track="true" href="d5a2cc4952abf462640f6251becb28c5.css" media="all" rel="stylesheet"/>
  <script data-turbolinks-track="true" src="0897bca9100de7e0f9a12fa32406bbe5.js">
  </script>
  <link href="a3ac983ebd62675a0f7b62917d9987f7.css" media="screen" rel="stylesheet"/>
  <link href="a94253de813a8b0f59ec67b62396ae63.css" media="screen" rel="stylesheet"/>
  <meta content="authenticity_token" name="csrf-param">
   <meta content="BKklVgo/26r1GmVK6J2LS+srIzhkw0+wzIQO3A7KBcJ59igjUhv/Eobnra4Ic/xCBYN1C66R3U81x9SkX9PyBA==" name="csrf-token"/>
  </meta>
 </head>
 <body>
  <section id="header">
   <a class="nodec header-title" href="index.html">
    <!--<div class="header-title"></div>-->
   </a>
  </section>
  <div class="wrapper">
   <div class="bodyWrapper">
    <section class="postBody bottomLine">
     <h1 class="postBody-title">
      Ethereum Beige Paperを日本語に訳してみる
     </h1>
     <span class="postBody-postInfo">
      2018/10/15
      <span class="postBody-category">
       <span class="postBody-category-colorBox" style="background-color: #707070;">
       </span>
       技術
      </span>
     </span>
     <div class="postBody-body">
      <p>
       最近ブロックチェーン（Ethereum）の勉強を初めて、簡単なDApp（分散型アプリケーション）を作ってみたりしてるんだけど、ブロックチェーンの難しい部分をうまい具合にライブラリがラップしてくれてて思った以上に楽に作れてしまう。
      </p>
      <p>
       それ自体はとてもうれしいんだけど、もっとEthereumの根幹の部分を知っておきたいなと思って、EthereumのBeige Paper（技術仕様みたいなもの）を読むことにした。
      </p>
      <p>
       （ほんとはYellow Paperというのが一番詳細に書かれているものなんだけど、数式が多くて文系の僕には辛そうだったから、より一般向けであるBeige Paperを選んだ。無念）
      </p>
      <p>
       といっても全部英語だし長さもあるから読んでると眠くなってしまう。
      </p>
      <p>
       そこで、日本語訳してブログに書かなきゃいけないとなれば否が応でも読むであろう、と思ってこの時給が発生しても良いくらいの辛いタスクを自分に課した次第でござる。
      </p>
      <p>
       それではどうぞ！
      </p>
      <p>
       ＊　一度に全部は無理なので、順々に訳していってこの記事を更新していくという形にします。
       <br/>
       ＊　僕自身この文書を理解しているわけではなく、皆さんのように理解しようとしている一人です。間違った訳があるかもしれないのであしからず。
       <br/>
       ＊
       <a class="blogPost-link" href="https://github.com/chronaeon/beigepaper/blob/master/beigepaper.pdf" target="_blank">
        原文
       </a>
      </p>
      <hr/>
      <h3>
       要約
      </h3>
      <p>
       Ethereum Protocolは決定論的、しかし実際には無限の状態機械であり二つの基本的な機能があります。一つはどこからでもアクセス可能なシングルトンの状態であること、二つ目はその状態に変化を与える仮想機械（VM）であることです。本書はこれら二つを構成するそれぞれの要素について説明するものです。
      </p>
      <h3>
       1 ビットコインを一つのコンピューターとして考える
      </h3>
      <p>
       EthereumはBitcoin由来の分散型台帳モデルを仮想コンピューターに応用したもので、Bitcoinのトランザクションのような確実性をマシンレベルのオペコードに与えます。Bitcoinの取引がコンセンサスメカニズムによって確実でタイムスタンプが正しいことと同じように、Ethereum上で実行された命令は確実に実行されます。
      </p>
      <p>
       言い換えると、Ethereumブロックチェーン上で実行されたプログラムは基本的に止めることが不可能です。これはEthereumではバグが起こり得ないという意味ではなく、Ethereumプログラムは外部要因に阻害されることなく実行されることが保証されている、という意味です。これは、暗号学の上に成り立っているブロックチェーン固有のセキュリティによる特徴です。
      </p>
      <h3>
       1.1 固有通貨
      </h3>
      <p>
       Ethereumは通貨としての利用を第一に考えられているわけではなく様々な利用法があります。そのため、計算力の利用過多によるネットワークの破綻を防ぐために基本的なネットワークコスト単位が存在します。これは「ガス」と呼ばれ、詳しくは第3章で説明します。ガスはEtherでのみ買うことができます。Ethereumにおける最小通貨単位はWeiで、1Weiは10e-18Etherです。Ethereumでのすべての通貨取引は内部的にはWeiで数えられます。また、Szabo、Finneyという単位もあり、それぞれ10e-6Ether、10e-3Etherに相当します。
      </p>
      <p>
       Ethereumネットワークに対して、固有通貨であるEtherのみが力を持ちます。計算力を意味するGas、それを唯一購入できるEtherをどの程度支払うことができるかが、システムができることを決定します。
      </p>
      <a href="/images/post_images/2018-10-15T07:49:28+00:00currency_table.png">
       <img class="postBody-image shadow1-h" src="db6b035883d96c5b0ae5e13027974f61.png" style="width: 584; height: 222;"/>
      </a>
      <h3>
       2 メモリとストレージ
      </h3>
      <h3>
       2.1 ワールドステート
      </h3>
      <p>
       「ワールドステート」（全体的な状態）はブロックによって区分されます。ある新しいブロックはつまり、ある新しいワールドステートであるということです。ワールドステートというのは
       <a class="blogPost-link" href="https://github.com/ethereum/wiki/wiki/%5BJapanese%5D-RLP" target="_blank">
        RLP
       </a>
       を利用して、以下の2つのマッピングで構成されています。
       <ol>
        <li>
         アドレス
        </li>
        <br/>
        <li>
         アカウントの状態
        </li>
       </ol>
       この情報は
       <a class="blogPost-link" href="https://github.com/ethereum/wiki/wiki/%5BJapanese%5D-Patricia-Tree" target="_blank">
        マークルパトリシアツリー
       </a>
       として、バイト配列とバイト配列のマッピングを行うデータベースに保存されます。結局、状態というのは状態データベースに存在するリレーション全てのことを指します。
      </p>
      <h3>
       2.1.1 マークルパトリシアツリー
      </h3>
      <p>
       マークルパトリシアツリーはマークルツリー（ハッシュ木）を応用したもので、各ノードがハッシュ値ではなくハッシュ値のそれぞれの文字を表しています。これにより、状態データ全体が各データへのパスを表すだけでなく、あるデータが実存したかどうかを暗号学的に証明します。言い換えると、通常のマークルツリー（ハッシュ木）とパトリシアツリー（基数木）を組み合わせることによってブロックチェーンを有効なものにします。Ethereumにおける全ての検索・並び替えアルゴリズムはこの厳重に正しいデータベースを通して行われるので、情報の正確さが保証されます。下の図は16進数のaと4から始まる探索木の例です。
      </p>
      <a href="/images/post_images/2018-10-16T13:13:24+00:00merkle_patricia_trie.png">
       <img class="postBody-image shadow1-h" src="1017030a63ff711d74c461f3e0736588.png" style="width: 448; height: 295;"/>
      </a>
      <h3>
       ツリーに関する用語
      </h3>
      <style>
       li {
  font-weight: 600;
}
      </style>
      <ul>
       <li>
        ルートノード
       </li>
       ツリーのルートノード。
       <li>
        子ノード
       </li>
       ルートを一番上と見たときに、あるノードの下についているノード。
       <li>
        親ノード
       </li>
       子ノードの逆。あるノードの上についているノード。
       <li>
        兄弟ノード
       </li>
       同じ親ノードを持つノード。
       <li>
        子孫ノード
       </li>
       あるノードから下方向にたどった時に行きつくノード。
       <li>
        先祖ノード
       </li>
       あるノードから上方向にたどった時に行きつくノード。
       <li>
        葉ノード
       </li>
       子ノードを持たないノード。
       <li>
        枝ノード
       </li>
       少なくとも一つは子ノードを持っているノード。
       <li>
        ディグリー（度数）
       </li>
       ノードから伸びるツリーの数。
       <li>
        エッジ
       </li>
       ノードとノードのつなぎ目
       <li>
        パス
       </li>
       あるノードからある子孫ノードへ行きつくときの経路。
       <li>
        レベル
       </li>
       あるノードのレベルとは、そのノードとルートノードの間にあるノードの数＋１。
       <li>
        ノードの高さ
       </li>
       あるノードの高さとは、そのノードより下にある葉の中で一番下にある葉とそのノードとの間にあるエッジの数。
       <li>
        ツリーの高さ
       </li>
       ルートノードの高さ。
       <li>
        深さ
       </li>
       あるノードの深さとは、そのノードとルートノードととの間にあるエッジの数。
       <li>
        森
       </li>
       0つ以上のつながっていない木の集合。
      </ul>
      <h3>
       2.1.1 RLPエンコーディング
      </h3>
      <p>
       （注：RLPは僕自身読んでて意味が良くわかりません笑
       <a class="blogPost-link" href="https://github.com/ethereum/wiki/wiki/%5BJapanese%5D-RLP" target="_blank">
        こちら
       </a>
       に公式の日本語説明がありますので参考にしてください。）
      </p>
      <p>
       RLPエンコーディングは状態データベースツリーに格納されるデータに施される処理で、それぞれのデータには16進数の接頭辞が付きます。この16進数値はあるデータの深さを決定します。RLPエンコードできるデータには2種類あります。
      </p>
      <ul>
       <li>
        バイト列
       </li>
       <li>
        アイテムのリスト
       </li>
      </ul>
      <p>
       RLPはバイナリデータの配列を任意の深さにエンコードします。これはEthereumでの主なシリアライズ手法です。RLPはデータの構造だけをエンコードするので、あらゆるデータタイプに依存しません。
      </p>
      <p>
       正の整数はビッグエンディアン方式で表され、後に0は続きません。つまり、RLPにおいて0という数字はと空のバイト配列になります。もし空ではない整数が0で始まっている場合、それは無効です。
      </p>
      <p>
       グローバルステートデータベースは検索速度を早めるためにRLPエンコードされています。RLPエンコーディングはアドレスと、そのアカウント状態のマッピングを作ります。それは各々のコンピューターに保存されているため、ツリーはネットワークの遅延なしにインデックス化、検索ができます。RLPは値をバイト配列として、また、最終的にはバイト配列になりますが、値の連続として扱います。
      </p>
      <h3>
       2.3 ブロック
      </h3>
      <p>
       ブロックは17つの要素でできています。そのうち15つはブロックヘッダーに含まれています。
      </p>
      <h3>
       2.3.1 ブロックヘッダー
      </h3>
      <p>
       トランザクションのリスト以外でブロックに含まれている情報。
      </p>
      <ol>
       <li>
        親ハッシュ
       </li>
       親ブロックヘッダーのKeccak-256ハッシュ。
       <li>
        オマーハッシュ
       </li>
       ブロックのオマー（親の親の子ブロック。人で言うと叔父・叔母にあたるブロック）のリストのKeccak-256ハッシュ。（オマーの存在意義は
       <a class="blogPost-link" href="https://coffeetimes.hatenadiary.jp/entry/2017/11/07/082426#Ommer%E3%81%AE%E8%AA%AC%E6%98%8E" target="_blank">
        こちらの記事
       </a>
       が分かりやすく説明してくれています。）
       <li>
        受益者
       </li>
       ブロックの賞金が与えられる20バイトのアドレス。
       <li>
        状態ルート
       </li>
       ブロックとトランザクションが確定した後の、ステートツリーのルートノードのKeccak-256ハッシュ。
       <li>
        トランザクションズルート
       </li>
       ブロックに入ってるトランザクションで作られたツリー構造のルートノードのKeccak-256ハッシュ。
       <li>
        レシートルート
       </li>
       ブロックに入ってるトランザクションのレシートで作られたツリー構造のルートノードのKeccak-256ハッシュ。
       <li>
        ログブルーム
       </li>
       ブロックに入ってるトランザクションのレシートのアドレスとトピックで作られたブルームフィルタ。
       <li>
        難易度
       </li>
       ブロックの難易度。前のブロックの難易度とタイムスタンプから計算される。
       <li>
        番号
       </li>
       あるブロックの祖先のブロックの数。
       <li>
        ガスリミット
       </li>
       ブロックのガス消費量の上限。
       <li>
        使用ガス
       </li>
       ブロックのトランザクションで実際に使用したガスの量。
       <li>
        タイムスタンプ
       </li>
       ブロック開始時のUnixタイムスタンプ。
       <li>
        エクストラデータ
       </li>
       32バイトのバイト配列で、ブロックに関する他のデータ。
       <li>
        ミックスハッシュ
       </li>
       ブロックに十分な計算がなされたことを示す32バイトのハッシュ。
       <li>
        ノンス
       </li>
       ブロックに十分な計算がなされたことを示す8バイトのハッシュ。
       <li>
        オマーブロックヘッダー
       </li>
       オマーのブロックヘッダー。
      </ol>
      <h3>
       2.3.2ブロックフッター
      </h3>
      <ul>
       <li>
        トランザクションシリーズ
       </li>
       ブロックの中でヘッダー以外に含まれる唯一の情報。
      </ul>
      <h3>
       2.3.3 ブロック番号と難易度
      </h3>
      <p>
       注目すべきはジェネシスブロックの難易度です。Homesteadの難易度パラメータはEIP-2で実装され、のちに説明しますが、ブロックの生成時間が変わると生成時間を恒常的に保とうと影響を与えようとします。Homesteadでは難易度は10万ブロックごとにゆっくりと、しかし指数関数的に上がるようになっています。そして結果的にブロック生成時間を変化させproof of stakeに移行するように時間的な圧力をかけます。「難易度爆弾」や「アイスエイジ」とも呼ばれるこの仕組みはEIP-649で紹介され、EIP-2で遅れて実装されました。またEIP-100では、叔父ブロックを含めたブロック生成時間の平均のために調整数xと分母9を用いた変更がなされました。最終的にビザンチウムではEIP-649で、実際のブロック番号から300万を引くことにより、つまりブロックの生成頻度をあげることにより偽のブロック番号を作り、アイスエイジは遅らされました。これはproof of stakeの開発時間を増やすためと、ネットワークの破綻を避けるためです。
      </p>
      <h3>
       2.3.4 アカウントの作成
      </h3>
      <p>
       アカウントの作成はコントラクトの作成を伴います。EVMのコードを含むボディを持つアカウントはメッセージを受け取るとそれを実行します。
      </p>
      <h3>
       2.3.5 アカウントのステート（状態）
      </h3>
      <p>
       アカウントのステートはあるワールドステートにおけるアカウントの詳細を含んでいます。アカウントステートは4つの変数でできています。
      </p>
      <ol>
       <li>
        ノンス
       </li>
       そのアドレスから送られたトランザクションの数、またはそのアドレスのアカウントが作成したコントラクトの数。
       <li>
        残高
       </li>
       そのアカウントが持っているweiの量。状態データベースの中にキー・値ペアで保存されています。
       <li>
        ストレージルート
       </li>
       アカウントのストレージの内容をエンコードしているマークルパトリシア木のルートノードの256ビット（32バイト）のハッシュ。
       <li>
        コードハッシュ
       </li>
       このアカウントのコントラクトのEVMコードのハッシュ値。コードハッシュはステートデータベースに保存されています。コードハッシュは不変で、そのアカウントのアドレスがメッセージを受けとった時に実行されます。
      </ol>
      <h3>
       2.3.6 ブルームフィルタ
      </h3>
      <p>
       ブルームフィルタはトランザクションリストに含まれるトランザクションのレシートのログのアドレスとトピックから成ります。
      </p>
      <h3>
       3 処理と計算
      </h3>
      <h3>
       3.1 トランザクション
      </h3>
      <p>
       Ethereumアカウントが互いに通信しあう時の基本的な手段です。トランザクションはEthereumネットワークに送られる、暗号学的に署名された指示です。トランザクションにはメッセージコールとコントラクト作成の二種類があります。トランザクションはEthereumの中で中心的な役割をし、プラットフォームの柔軟性とダイナミズムの為に重要なものです。トランザクションは状態の遷移、つまりブロックで行われる計算を含むブロックの追加、を担う重要なものです。それぞれのトランザクションは、ブロックが確定されワールドステートに追加される前のマシンステートという一時的なステートに変化を及ぼします。
      </p>
      <h3>
       3.1.1 トランザクションルート
      </h3>
      <p>
       ブロックのトランザクションリストに入っているトランザクションのルートノードのKeccak-256ハッシュ。
      </p>
      <ol>
       <li>
        ノンス
       </li>
       送り手が送ったトランザクションの数。
       <li>
        ガス価格
       </li>
       ネットワークに支払うガス単位のwei。
       <li>
        ガス上限
       </li>
       トランザクションの実行に使用するガス量の上限。
       <li>
        宛先
       </li>
       メッセージの受けてを表す20文字。
       <li>
        量
       </li>
       受けてに送られるweiの量。
      </ol>
      <h3>
       3.2 状態遷移関数
      </h3>
      <p>
       状態遷移は状態遷移関数を通して起こります。状態遷移関数はマシンステートの変化をワールドステートに反映する際に行われる、様々な処理を高度に抽象化したものです。
      </p>
      <h3>
       3.3 採掘
      </h3>
      <p>
       ブロック受益者は160ビット（20バイト）のアドレスで、ブロックの採掘が成功した際に全ての手数料が送られます。Apply Rewardsはブロックの確定処理の三つ目で賞金をアカウントのアドレスに送ります。これは現在のブロックの難易度に関連したスカラー値です。
      </p>
      <h3>
       3.4 検証
      </h3>
      <p>
       オマーヘッダーの検証をするEVMの処理。
      </p>
      <h3>
       3.5 送り手の関数
      </h3>
      <p>
       トランザクションとその送り手を結び付ける説明でSECP-256k1曲線のECDSAを用います。
      </p>
      <h3>
       3.6 シリアライズ・デシリアライズ
      </h3>
      <p>
       この関数は正の整数をビッグエンディアンで表されるバイト配列に拡張します。"・"演算子を伴うとき、連結をします。big_endian関数はRLPシリアライズ・デシリアライズを伴います。
      </p>
      <h3>
       3.7 Ethereum仮想マシン（EVM）
      </h3>
      <p>
       EVMは単純なスタックベースの構造でできています。仮想マシンのワードサイズ、つまりはスタックサイズは256ビットです。これはKeccak-256ハッシュと楕円曲線を利用した計算をすることから決められました。メモリは単純なワードアドレッシングのバイト配列です。メモリsTACは最大1024ビットです。マシンは独立したストレージを持っています。これはメモリと似ていますが、バイト配列ではなくワードアドレッシング可能なワード配列です。揮発性であるメモリとは違い、ストレージは揮発性ではなくシステムステートの一部として管理されています。
      </p>
      <p>
       ストレージとメモリは両方とも最初はすべて0です。マシンは通常のノイマンアーキテクチャには従いません。プログラムコードを一般アクセス可能なメモリやストレージに置くのではなく、特定の手順を踏んでのみアクセス可能な仮想ROMに置いてあります。マシンはスタックアンダーフローや無効な操作により、例外的な動作をすることがあります。ガス不足例外のようなときには状態の変化をそのままにすることはありません。マシンはすぐに停止し、実行者（トランザクションを起こした者、または再帰的にたどった実行者）に報告します。報告を受けたものはその例外を適切に対処します。
      </p>
      <h3>
       3.7.1 料金
      </h3>
      <p>
       料金（ガスで計算される）は三つの状況で発生し、三つとも処理の実行に必要不可欠なものです。一つ目は最もよくある状況で、処理実行時の計算力に対する料金です。二つ目は下位のメッセージコールやコントラクト生成のための料金として発生することがあります。CREATE、CALL、CALLCODEの処理に対しての料金が含まれます。三つめは、メモリ使用料の増加時に料金が発生することがあります。
      </p>
      <p>
       処理の実行に際してのメモリ使用に対する料金は、読み書きどちらにしても全てのメモリインデックスが含まれるような32バイトの倍数の中での最小数に比例します。料金はその時々に発生します。たとえば以前にインデックス化されたメモリより32バイト以上大きいメモリエリアを参照した時、追加の料金が発生します。このため、アドレスが32ビットを超えることはほとんどありません。
      </p>
      <p>
       実装は最終的にはこれを管理しなければなりません。ストレージは使用容量を減らすことを動機づけるような料金体系をしています。（全てのノードのステートデータベースの肥大化に直接かかわるため。）ストレージの内容を削除するときには料金はかからないばかりか、むしろ返金がされます。通常のストレージ使用よりも最初のストレージ使用の方がコストがかかるため、返金は前もって行われます。
      </p>
      <h3>
       3.8 実行
      </h3>
      <p>
       トランザクションの実行は状態遷移関数を定義します。しかし、いかなるトランザクションでも実行される前に内部状態が有効かどうかを確かめるためにテストを行う必要があります。
      </p>
      <h3>
       3.8.1 内部の有効性
      </h3>
      <ul>
       <li>
        トランザクションがRLPのルールにのっとっていること。
       </li>
       <li>
        トランザクションの署名が有効であること。
       </li>
       <li>
        トランザクションのノンスが有効であること。つまり、送り手のアカウントのノンスと等しいこと。
       </li>
       <li>
        gas_limitがトランザクションで使用されるintrinsic_gasよりも等しいか大きいこと
       </li>
       <li>
        送り手が前もって発生する支払い金額よりも多い金額を所持していること。
       </li>
      </ul>
      <h3>
       3.8.2 トランザクションレシート
      </h3>
      <p>
       実行にかかった料金とトランザクションのログは保存されますが、トランザクションの実行結果はトランザクションのレシートtx_receiptに保存されます。トランザクションレシートにはトランザクションの実行に際して発生したログイベントlogs_setと、それらのログイベントからの実際の情報を含むブルームフィルタであるlogs_bloomがあります。さらに、トランザクション後の状態であるpost_transaction(state)と、そのトランザクションを含むブロックが使用したガスの量gas_usedがトランザクションレシートに記録されています。結果的に、トランザクションレシートは様々な実行の記録です。
      </p>
      <p>
       有効なトランザクションの実行ははステートを永久に変更させることから始まります。送り手のノンスは1増え、所持金はトランザクションの実行前に支払う必要のある合計料金collateral_gasの分だけ減ります。メッセージコールやコントラクト生成がコントラクトアカウントのコード実行によるものであるとき、トランザクションの実行者と送り手は同じではありません。
      </p>
      <p>
       トランザクションが実行された後、最終段階の一歩手前であるPROVISIONAL_STATEに入ります。world_stateに変化を及ぼす前に一つ一つのEVMオペコードの実行に使用されたガスは以下を生成します。
      </p>
      <ul>
       <li>
        仮のステート
       </li>
       <li>
        内部ガスと関連するサブステート
       </li>
       <li>
        トランザクション完了後の自壊に紐づけられたアカウント。self_destruct(accounts)
       </li>
       <li>
        フロントエンドアプリケーションのために生成されるEVMコード実行のチェックポイントで、tx_receiptからのlogs_setとlogs_bloomが含まれます。
       </li>
       <li>
        返金金額
       </li>
      </ul>
      <p>
       コードの実行はいつもガスを減少させます。もしガスが尽きたときout-of-gas error(oog)が発生し、結果のステートは空のセットとして定義されワールドステートには何も影響を及ぼしません。これがEthereumのトランザクションのような特徴を形作っています。WORLD STATEを変化させるためには全ての処理を通過しなければならず、そうでない場合完全に変化を及ぼしません。
      </p>
      <h3>
       3.8.3 コードデポジット
      </h3>
      <p>
       To be continued...
      </p>
     </div>
    </section>
    <div class="postComment bottomLine">
     <form accept-charset="UTF-8" action="/comment?post_id=52" method="post">
      <input name="utf8" type="hidden" value="✓"/>
      <input name="authenticity_token" type="hidden" value="u9nLU4vS4r5DO6qXUkgAyw/aedLaL/VKazBS7eNWbIXGhsYm0/bGBjDGYnOypnfC4XIv4RB9Z7WSc4iVsk+bQw=="/>
      <label for="name">
       Name
      </label>
      <br/>
      <input class="postComment-textField" id="name" name="name" type="text" value=""/>
      <span id="postComment-warning" style="color: #F00; display: none;">
       <br/>
       Please enter your name.
      </span>
      <br/>
      <br/>
      <label for="comment">
       Comment
      </label>
      <br/>
      <textarea class="postComment-textArea" id="comment" name="comment">
</textarea>
      <br/>
      <br/>
      <input class="button1" data-disable-with="submit" id="submit_comment" name="commit" type="submit" value="submit"/>
     </form>
    </div>
   </div>
   <script>
    $("#submit_comment").click(function(event) {
    if(!$("#name").val()){
      event.preventDefault()
      $("#postComment-warning").show()
    } 
  })
   </script>
  </div>
 </body>
</html>
